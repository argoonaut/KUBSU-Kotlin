package com.example.airlinesapp

import android.os.Bundle
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.FragmentTransaction
import com.example.airlinesapp.repository.AppRepository
import com.example.airlinesapp.ui.*
import java.util.*


class MainActivity : AppCompatActivity(), AirlineListFragment.Callbacks,
    CityListFragment.Callbacks, FlightListFragment.Callbacks {

    // Вызывается при создании Activity
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Инициализация репозитория приложения
        AppRepository.newInstance()

        // Загрузка данных из репозитория
        AppRepository.get().loadData(this)

        // Установка макета для Activity
        setContentView(R.layout.activity_main)

        // Замена основного фрагмента на AirlineListFragment
        supportFragmentManager
            .beginTransaction()
            .replace(R.id.mainFrame, AirlineListFragment.newInstance(), AIRLINE_LIST_TAG)
            .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
            .commit()

        // Обработка нажатия кнопки "назад". Если в стеке фрагментов есть элементы, то выполняется возврат назад,
        // иначе заканчивается работа Activity
        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (supportFragmentManager.backStackEntryCount > 0) {
                    supportFragmentManager.popBackStack()
                } else
                    finish()
            }
        })
    }

    // Вызывается, когда Activity перестает быть видимой для пользователя
    override fun onStop() {
        super.onStop()

        // Сохранение данных в репозитории при остановке Activity
        AppRepository.get().saveData(this)
    }

    // Установка заголовка Activity
    override fun setTitle(_title: String) {
        title = _title
    }

    // Отображение фрагмента со списком городов авиакомпании с заданным id
    override fun showAirline(id: UUID) {
        supportFragmentManager
            .beginTransaction()
            .replace(R.id.mainFrame, CityListFragment.newInstance(id), CITY_LIST_TAG)
            .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
            .addToBackStack(null)
            .commit()
    }
}
/*

RecyclerView в Android — это расширенный виджет для отображения больших наборов данных, которые
могут быть прокручены внутри приложения. Информация в RecyclerView обычно представляет собой список
элементов, где каждый элемент в этом списке использует одно и то же макет.(Airline, Flight)
----------------------------------------------------------------------------------------------------
MutableLiveData - это класс в библиотеке Android Jetpack, которая расширяет LiveData. Это обобщенный
 класс, используемый для хранения и наблюдения за данными, которые могут меняться.

LiveData - это класс хранилища данных, который имеет несколько преимуществ. Он может быть
наблюдаемым, то есть любой компонент (обычно это активность или фрагмент) может подписаться на
изменения в данных, хранящихся в объекте LiveData. Когда данные меняются, все наблюдатели
уведомляются об этом.

Однако, LiveData - это неизменяемый объект, то есть вы не можете напрямую изменить данные,
хранящиеся в нем. Это где MutableLiveData становится полезным. MutableLiveData предоставляет два
дополнительных метода, setValue(T) и postValue(T), которые позволяют изменять данные, хранящиеся
в объекте MutableLiveData.
----------------------------------------------------------------------------------------------------
Activity в Android - это ключевой компонент любого Android-приложения. Он представляет собой одно
окно, которое пользователь может видеть на экране в любой момент времени.
----------------------------------------------------------------------------------------------------
Жизненный цикл Activity в Android относится к набору методов, которые система вызывает при изменении
 состояния Activity. Эти состояния и методы включают:

onCreate(): Этот метод вызывается при первоначальном создании Activity. Здесь происходит
инициализация основных компонентов, таких как создание пользовательского интерфейса через метод
setContentView() и получение данных, переданных через интенты.

onStart(): Этот метод вызывается после onCreate() или если Activity возвращается в передний план
после остановки. Activity становится видимой пользователю, но еще не доступна для взаимодействия.

onResume(): Этот метод вызывается, когда Activity начинает взаимодействовать с пользователем.
В этом состоянии Activity находится в вершине стека Activity и имеет фокус ввода.

onPause(): Этот метод вызывается, когда система собирается возобновить другую Activity и
текущая Activity больше не будет иметь фокус ввода. Обычно здесь происходит сохранение
незакрепленных данных и остановка анимаций или других элементов, которые могут потреблять ЦП.

onStop(): Этот метод вызывается, когда Activity больше не видима пользователю. Это может произойти,
если была запущена новая Activity, которая занимает весь экран, или если текущая Activity была
уничтожена системой.

onDestroy(): Этот метод вызывается перед уничтожением Activity. Это может произойти либо потому,
что Activity заканчивает свою работу (например, при вызове finish()), либо потому, что система
временно уничтожает процесс для освобождения памяти.

onRestart(): Этот метод вызывается, когда остановленная Activity возвращается на передний план.
После вызова onRestart(), система вызывает метод onStart().

Важно правильно управлять этими методами, чтобы обеспечить гладкое взаимодействие пользователя
с вашим приложением и избежать таких проблем, как утечки памяти и зависание приложения.
----------------------------------------------------------------------------------------------------
MVVM (Model-View-ViewModel) - это архитектурный паттерн проектирования, который предлагает
структурированный способ разделения логики приложения от пользовательского интерфейса.
Это позволяет создавать более модульные, тестируемые и управляемые приложения.

Модель MVVM состоит из трех основных компонентов:

Model: Это компонент, который отвечает за обработку данных приложения. Он может включать в себя
различные компоненты для доступа к данным, такие как базы данных, веб-сервисы и репозитории.
Model не знает о View и ViewModel.

View: Это компонент, который отображает пользовательский интерфейс и обрабатывает пользовательский
ввод. В Android View обычно представляет собой активность, фрагмент или его XML макет.

ViewModel: Это мост между Model и View. ViewModel извлекает данные из Model и форматирует их для
отображения в View. ViewModel также обрабатывает команды от View и обновляет Model соответственно.
Важно отметить, что ViewModel не должен знать об устройстве, на котором он работает, он не должен
иметь ссылок на контекст Activity или Fragment.

Основная идея MVVM заключается в том, чтобы сделать View как можно более "глупым" и убрать всю
бизнес-логику из него. Это достигается с помощью привязки данных (data binding), которая позволяет
напрямую связывать данные ViewModel с элементами пользовательского интерфейса в View.

Библиотека LiveData в Android упрощает реализацию MVVM, так как ViewModel может использовать
LiveData для хранения данных, которые затем автоматически обновляют View при изменении данных.

MVVM является предпочтительным подходом для разработки Android-приложений в соответствии с
рекомендациями Google.
----------------------------------------------------------------------------------------------------
 */